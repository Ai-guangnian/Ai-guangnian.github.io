{"meta":{"title":"Ai-guangnian","subtitle":"一天进步一点","description":"Love Life","author":"Guangnian","url":"http://Ai-guangnian.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-05-11T15:25:13.000Z","updated":"2020-05-11T15:30:17.429Z","comments":true,"path":"categories/index.html","permalink":"http://ai-guangnian.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"索引和B+树原理","slug":"索引和B-树原理","date":"2020-05-12T14:38:54.000Z","updated":"2020-05-12T14:45:20.076Z","comments":true,"path":"2020/05/12/索引和B-树原理/","link":"","permalink":"http://ai-guangnian.github.io/2020/05/12/%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E5%8E%9F%E7%90%86/","excerpt":"","text":"在 MySQL 中，主要有四种类型的索引，分别为：B-Tree 索引， Hash 索引， Fulltext 索引和 R-Tree 索引。B-Tree 索引是 MySQL 数据库中使用最为频繁的索引类型，除了 Archive 存储引擎之外的其他所有的存储引擎都支持 B-Tree 索引。Archive 引擎直到 MySQL 5.1 才支持索引，而且只支持索引单个 AUTO_INCREMENT 列。不仅仅在 MySQL 中是如此，实际上在其他的很多数据库管理系统中B-Tree 索引也同样是作为最主要的索引类型，这主要是因为 B-Tree 索引的存储结构在数据库的数据检索中有非常优异的表现。一般来说， MySQL 中的 B-Tree 索引的物理文件大多都是以 Balance Tree 的结构来存储的，也就是所有实际需要的数据都存放于 Tree 的 Leaf Node(叶子节点) ，而且到任何一个 Leaf Node 的最短路径的长度都是完全相同的，所以我们大家都称之为 B-Tree 索引。当然，可能各种数据库（或 MySQL 的各种存储引擎）在存放自己的 B-Tree 索引的时候会对存储结构稍作改造。如 Innodb 存储引擎的 B-Tree 索引实际使用的存储结构实际上是 B+Tree，也就是在 B-Tree 数据结构的基础上做了很小的改造，在每一个Leaf Node 上面出了存放索引键的相关信息之外，还存储了指向与该 Leaf Node 相邻的后一个 LeafNode 的指针信息（增加了顺序访问指针），这主要是为了加快检索多个相邻 Leaf Node 的效率考虑。InnoDB是Mysql的默认存储引擎(Mysql5.5.5之前是MyISAM） B-树、B+树概念B树即二叉搜索树： 所有非叶子结点至多拥有两个儿子（Left和Right）； 所有结点存储一个关键字； 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树； B-树是一种多路搜索树（并不是二叉的）： 定义任意非叶子结点最多只有M个儿子；且M&gt;2； 根结点的儿子数为[2, M]； 除根结点以外的非叶子结点的儿子数为[M/2, M]； 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 非叶子结点的关键字个数=指向儿子的指针个数-1； 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]； 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 所有叶子结点位于同一层； B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点； B-树的特性： 关键字集合分布在整颗树中； 任何一个关键字出现且只出现在一个结点中； 搜索有可能在非叶子结点结束； 其搜索性能等价于在关键字全集内做一次二分查找； 自动层次控制； 由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率。所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并； B+树B+树是B-树的变体，也是一种多路搜索树： 其定义基本与B-树同，除了： 非叶子结点的子树指针与关键字个数相同； 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）； 为所有叶子结点增加一个链指针； 所有关键字都在叶子结点出现； B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找； B+的特性： 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 更适合文件索引系统； 建索引的几大原则1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式 3.尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录 4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’); 5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可","categories":[{"name":"数据库","slug":"数据库","permalink":"http://ai-guangnian.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://ai-guangnian.github.io/tags/MYSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://ai-guangnian.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL连接","slug":"sjk连接","date":"2020-05-12T14:31:30.000Z","updated":"2020-05-12T14:36:27.120Z","comments":true,"path":"2020/05/12/sjk连接/","link":"","permalink":"http://ai-guangnian.github.io/2020/05/12/sjk%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"1.INNER JOIN（内连接） 1234SELECT &lt;select_list&gt; FROM Table_A AINNER JOIN Table_B BON A.Key = B.Key 2.LEFT JOIN（左连接） 1234SELECT &lt;select_list&gt;FROM Table_A ALEFT JOIN Table_B BON A.Key = B.Key 3.RIGHT JOIN（右连接） 1234SELECT &lt;select_list&gt;FROM Table_A ARIGHT JOIN Table_B BON A.Key = B.Key 4.OUTER JOIN（外连接） 1234SELECT &lt;select_list&gt;FROM Table_A AFULL OUTER JOIN Table_B BON A.Key = B.Key 5.LEFT JOIN EXCLUDING INNER JOIN（左连接-内连接） 12345SELECT &lt;select_list&gt; FROM Table_A ALEFT JOIN Table_B BON A.Key = B.KeyWHERE B.Key IS NULL 6.RIGHT JOIN EXCLUDING INNER JOIN（右连接-内连接） 12345SELECT &lt;select_list&gt;FROM Table_A ARIGHT JOIN Table_B BON A.Key = B.KeyWHERE A.Key IS NULL 7.OUTER JOIN EXCLUDING INNER JOIN（外连接-内连接） 12345SELECT &lt;select_list&gt;FROM Table_A AFULL OUTER JOIN Table_B BON A.Key = B.KeyWHERE A.Key IS NULL OR B.Key IS NULL","categories":[{"name":"数据库","slug":"数据库","permalink":"http://ai-guangnian.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://ai-guangnian.github.io/tags/SQL/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://ai-guangnian.github.io/tags/MYSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://ai-guangnian.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"事务隔离","slug":"sjk","date":"2020-05-12T12:21:42.000Z","updated":"2020-05-12T14:31:11.731Z","comments":true,"path":"2020/05/12/sjk/","link":"","permalink":"http://ai-guangnian.github.io/2020/05/12/sjk/","excerpt":"","text":"脏读当一个事务读取到另外一个事务修改但未提交的数据时，就可能发生脏读。事务2修改了一行，但是没有提交，事务1读了这个没有提交的数据。现在如果事务2回滚了刚才的修改或者做了另外的修改的话，事务1中查到的数据就是不正确的了，所以这条数据就是脏读。 不可重复读“不可重复读”现象发生在当执行SELECT 操作时没有获得读锁或者SELECT操作执行完后马上释放了读锁；另外一个事务对数据进行了更新，读到了不同的结果。事务2提交成功，因此他对id为1的行的修改就对其他事务可见了。导致了事务1在此前读的age=1，第二次读的age=2，两次结果不一致,这就是不可重复读。 幻读“幻读”又叫”幻象读”,是’’不可重复读’’的一种特殊场景：当事务1两次执行’’SELECT … WHERE’’检索一定范围内数据的操作中间，事务2在这个表中创建了(如[[INSERT]])了一行新数据，这条新数据正好满足事务1的“WHERE”子句。 脏读：指读到了其他事务未提交的数据。 不可重复读：读到了其他事务已提交的数据(update)。 不可重复读与幻读都是读到其他事务已提交的数据,但是它们针对点不同。 不可重复读：update。 幻读：delete，insert。 MySQL中的四种事务隔离级别未提交读未提交读（READ UNCOMMITTED）是最低的隔离级别，在这种隔离级别下，如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。 已提交读由于MySQL的InnoDB默认是使用的RR级别，所以我们先要将该session开启成RC级别，并且设置binlog的模式SET session transaction isolation level read committed;SET SESSION binlog_format = ‘ROW’;（或者是MIXED）在已提交读（READ COMMITTED）级别中，读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行，会对该写锁一直保持直到到事务提交。 可重复读在可重复读（REPEATABLE READS）是介于已提交读和可串行化之间的一种隔离级别(废话😅)，它是InnoDb的默认隔离级别，它是我这篇文章的重点讨论对象，所以在这里我先卖个关子,后面我会详细介绍。 可串行化可串行化（Serializable ）是高的隔离级别，它求在选定对象上的读锁和写锁保持直到事务结束后才能释放，所以能防住上诉所有问题，但因为是串行化的，所以效率较低。 悲观锁与乐观锁 我们前面说的在对象上加锁，是一种悲观锁机制。有很多文章说可重复读的隔离级别防不了幻读，是认为可重复读会对读的行加锁，导致他事务修改不了这条数据，直到事务结束。但是这种方案只能锁住数据行，如果有新的数据进来，是阻止不了的，所以会产生幻读。 悲观锁正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。 乐观锁相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。MySQL、ORACLE、PostgreSQL等都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免不可重复读和幻读,MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://ai-guangnian.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://ai-guangnian.github.io/tags/SQL/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://ai-guangnian.github.io/tags/MYSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://ai-guangnian.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL和索引","slug":"shujuku","date":"2020-05-12T11:54:56.000Z","updated":"2020-05-12T12:23:12.486Z","comments":true,"path":"2020/05/12/shujuku/","link":"","permalink":"http://ai-guangnian.github.io/2020/05/12/shujuku/","excerpt":"","text":"==Why MySQL== 在众多开源免费的关系型数据库系统中，MySQL有以下比较出众的优势： 运行速度快 易使用 SQL语言支持 移植性好 功能丰富 成本低廉 ==MySQL中myisam与innodb的区别====MyISAM：== 不支持事务，但是每次查询都是原子的； 支持表级锁，即每次操作对整个表加锁； 存储表的总行数； 一个MYISAM表有三个文件：索引文件、表结构文件、数据文件； 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。 ==InnoDb：== 支持ACID的事务，支持事务的四种隔离级别； 支持行级锁及外键约束：因此可以支持写并发； 不存储总行数； 一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制； 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。 ==两者的适用场景：== 因为MyISAM相对简单所以在效率上要优于InnoDB.如果系统读多，写少。对原子性要求低。那么MyISAM最好的选择。且MyISAM恢复速度快。可直接用备份覆盖恢复。 如果系统读少，写多的时候，尤其是并发写入高的时候。InnoDB就是首选了。 ==MySQL的索引类型，并分别简述一下各自的场景。== 普通索引：没有任何限制条件的索引，该索引可以在任何数据类型中创建。 唯一索引：使用UNIQUE参数可以设置唯一索引。创建该索引时，索引列的值必须唯一，但允许有空值。通过唯一索引，用户可以快速地定位某条记录，主键索引是一种特殊的唯一索引。 全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引耗时耗空间。 空间索引：只能建立在空间数据类型上。这样可以提高系统获取空间数据类型的效率。仅可用于 MyISAM 表，索引的字段不能为空值。使用SPATIAL参数可以设置索引为空间索引。 单列索引：只对应一个字段的索引。 多列索引：在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段，用户可以通过这几个字段进行查询，想使用该索引，用户必须使用这些字段中的一个字段。 ==Why Index== 从概念上讲，数据库是数据表的集合，数据表是数据行和数据列的集合。当你执行一个SELECT语句从数据表中查询部分数据行的时候，得到的就是另外一个数据表和数据行的集合。当然，我们都希望获得这个新的集合的时间尽可能地短，效率尽可能地高，这就是优化查询。提升查询速度的技术有很多，其中最重要的就是索引。当你发现自己的查询速度慢的时候，最快解决问题的方法就是使用索引。索引的使用是影响查询速度的重要因素。在使用索引之前其他的优化查询的动作纯粹是浪费时间，只有合理地使用索引之后，才有必要考虑其他优化方式。 ==创建索引==三种方式：使用CREATE INDEX创建，语法如下： 1CREATE INDEX indexName ON tableName (columnName(length)); 例如我们对ip_address这一列创建一个长度为16的索引： 1CREATE INDEX index_ip_addr ON t_user_action_log (ip_address(16)); 使用ALTER语句创建，语法如下： 1ALTER TABLE tableName ADD INDEX indexName(columnName); ALTER语句创建索引前面已经有例子了。下面提供一个设置索引长度的例子： 123ALTER TABLE t_user_action_log ADD INDEX ip_address_idx (ip_address(16));SHOW INDEX FROM t_user_action_log; ==查看索引==可以通过show语句查看索引： 1SHOW INDEX FROM t_user_action_log; ==删除索引==使用ALTER命令可以删除索引，例如： 1ALTER TABLE t_user_action_log DROP INDEX index_ip_addr; ==索引的使用原则== ==写操作比较频繁的列慎重加索引==索引在提高查询速度的同时，也由于需要更新索引而带来了降低插入、删除和更新带索引列的速度的问题。一张数据表的索引越多，在写操作的时候性能下降的越厉害。 ==索引越多占用磁盘空间越大==与没有加索引比较，加索引会更快地使你的磁盘接近使用空间极限。 ==不要为输出列加索引==为查询条件、分组、连接条件的列加索引，而不是为查询输出结果的列加索引。例如下面的查询语句： 1234select ip_address from t_user_action_logwhere name='LiSi'group by actionorder by create_time; 所以可以考虑增加在 name action create_time 列上，而不是 ip_address。 ==考虑维度优势==例如action列的值包含：1、2、3、4、5，那么该列的维度就是5。维度越高（理论上维度的最大值就是数据行的总数），数据列包含的独一无二的值就越多，索引的使用效果越好。对于维度很低的数据列，索引几乎不会起作用，因此没有必要加索引。例如性别列的值只有男和女，每种查询结果占比大约50%。一般当查询优化处理器发现查询结果超过全表的30%的时候，就会跳过索引，直接进行全表扫描。 ==对短小的值加索引==对短小的值加索引，意味着索引所占的空间更小，可以减少I/O活动，同时比较索引的速度也更快。尤其是主键，要尽可能短小。另外，InnoDB使用的是聚集索引（clustered index），也就是把主键和数据行保存在一起。主键之外的其他索引都是二级索引，这些二级索引也保留着一份主键，这样在查询到索引以后，就可以根据主键找到对应的数据行。如果主键太长的话，会造成二级索引占用的空间变大。 ==为字符串前缀加索引==前边已经讲过短小索引的种种好处了，有时候一个字符串的前几个字符就能唯一标识这条记录，这个时候设置索引的长度就是非常划算的做法。前面已经提供了设置索引length的例子，这里就不举例子了。 ==复合索引的左侧索引==创建复合索引的语法如下： 1CREATE INDEX indexName ON tableName (column1 DESC, column2 DESC, column3 ASC); ==索引加锁==对于InnoDB来说，索引可以让查询锁住更少的行，从而可以在并发情况下拥有更佳表现。下面演示一下查询锁与索引之间的关系。前面使用的t_user_action_log表目前有一个id为主键，还有一个二级索引action。下面这条语句的修改范围是id值为1 2 3 4所在的行，查询锁会锁住id值为1 2 3 4 5所在的行。update ijiangtao_local_db_mysql.t_user_action_log set name=’c1’ where id&lt;5;首先创建数据库连接1，开启事务，并执行update语句 12345set autocommit=0;begin;update ijiangtao_local_db_mysql.t_user_action_log set name='c1' where id&lt;5; 然后开启另外一个连接2，分别执行下面几个update语句 – 没有被锁update ijiangtao_local_db_mysql.t_user_action_log set name=’c2’ where id=6;– 被锁update ijiangtao_local_db_mysql.t_user_action_log set name=’c2’ where id=5;你会发现id=5的数据行已经被锁定，id=6的数据行可以正常提交。连接1提交事务，连接2的id=1和id=5的数据行可以update成功了。 12-- 在连接1提交事务commit; 如果不使用索引ip_address没有索引的话，会锁定全表。连接1开启事务以后commit;之前，连接2对该表的update全部需要等待连接1释放锁。 12345set autocommit=0;begin;update ijiangtao_local_db_mysql.t_user_action_log set name='c1' where ip_address='8. ==覆盖索引==如果索引包含满足查询的所有数据，就被称为覆盖索引(Covering Indexes)，覆盖索引非常强大，可以大大提高查询性能。 覆盖索引高性能的原因是：索引通常比记录要小，覆盖索引查询只需要读索引，而不需要读记录。索引都按照值的大小进行顺序存储，相比与随机访问记录，需要更少的I/0。大多数数据引擎能更好的缓存索引，例如MyISAM只缓存索引。 ==聚簇索引==聚簇索引(Clustered Indexes)保证关键字的值相近的元组存储的物理位置也相同，且一个表只能有一个聚簇索引。字符串类型不建议使用聚簇索引，特别是随机字符串，因为它们会使系统进行大量的移动操作。并不是所有的存储引擎都支持聚簇索引，目前InnoDB支持。如果使用聚簇索引，最好使用AUTO_INCREMENT列作为主键，应该尽量避免使用随机的聚簇主键。从物理位置上看，聚簇索引表比非聚簇的索引表，有更好的访问性能。选择合适的索引类型从数据结构角度来看，MySQL支持的索引类型有B树索引、Hash索引等。 ==B树索引==B树索引对于&lt;、&lt;=、 =、 &gt;=、 &gt;、 &lt;&gt;、!=、 between查询，进行精确比较操作和范围比较操作都有比较高的效率。B树索引也是InnoDB存储引擎默认的索引结构。 ==Hash索引==Hash索引仅能满足=、&lt;=&gt;、in查询。Hash索引检索效率非常高，索引的检索可以一次定位，不像B树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的I/O访问，所以Hash索引的查询效率要远高于B树索引。但Hash索引不能使用范围查询。 ==查询优化建议==下面提供几个查询优化的建议。==使用explain分析查询语句==前面已经演示过如何使用explain命令分析查询语句了，这里再解释一下其中几个有参考价值的字段的含义： select_typeselect_type表示查询中每个select子句的类型，一般有下面几个值: SIMPLE简单SELECT,不使用UNION或子查询等。 PRIMARY查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY。 UNIONUNION中的第二个或后面的SELECT语句。 DEPENDENT UNIONUNION中的第二个或后面的SELECT语句，取决于外面的查询。 UNION RESULTUNION的结果。 SUBQUERY子查询中的第一个SELECT。 DEPENDENT SUBQUERY子查询中的第一个SELECT，取决于外面的查询。 DERIVED派生表的SELECT, FROM子句的子查询。 UNCACHEABLE SUBQUERY一个子查询的结果不能被缓存，必须重新评估外链接的第一行。 typetype表示MySQL在表中找到所需行的方式，又称“访问类型”，常用的类型有：ALL, index, range, ref, eq_ref, const, system, NULL。从左到右，性能从差到好。 ALL：Full Table Scan，MySQL将遍历全表以找到匹配的行。 index:Full Index Scan，index与ALL区别为index类型只遍历索引树。 range:只检索给定范围的行，使用一个索引来选择行。 ref:表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。 eq_ref:类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件。 const:当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。 NULL:MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。 Keykey列显示MySQL实际决定使用的键（索引），如果没有选择索引，键是NULL。 possible_keyspossible_keys指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上如果存在索引则该索引将被列出，但不一定被查询使用。 refref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。 rowsrows表示MySQL根据表统计信息，以及索引选用的情况，找到所需记录需要读取的行数。这个行数是估算的值，实际行数可能不同。用好explain命令是查询优化的第一步 ! ==声明NOT NULL==当数据列被声明为NOT NULL以后，在查询的时候就不需要判断是否为NULL，由于减少了判断，可以降低复杂性，提高查询速度。如果要表示数据列为空，可以使用0等代替。 ==考虑使用数值类型代替字符串==MySQL对数值类型的处理速度要远远快于字符串，而且数值类型往往更加节省空间。例如对于“Male”和“Female”可以用“0”和“1”进行代替。 ==考虑使用ENUM类型==如果你的数据列的取值是确定有限的，可以使用ENUM类型代替字符串。因为MySQL会把这些值表示为一系列对应的数字，这样处理的速度会提高很多。 123456789CREATE TABLE shirts ( name VARCHAR(40), size ENUM('x-small', 'small', 'medium', 'large', 'x-large'));INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'), ('polo shirt','small');SELECT name, size FROM shirts WHERE size = 'medium';","categories":[{"name":"数据库","slug":"数据库","permalink":"http://ai-guangnian.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://ai-guangnian.github.io/tags/SQL/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://ai-guangnian.github.io/tags/MYSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://ai-guangnian.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"集合","slug":"JH","date":"2020-05-12T03:09:19.000Z","updated":"2020-05-12T10:12:54.430Z","comments":true,"path":"2020/05/12/JH/","link":"","permalink":"http://ai-guangnian.github.io/2020/05/12/JH/","excerpt":"==框架== 1、Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。Set是一个不允许有重复元素的集合。Set的实现类有HashSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 2、Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。 3、接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。 4、再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。 5、最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。","text":"==框架== 1、Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。Set是一个不允许有重复元素的集合。Set的实现类有HashSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 2、Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。 3、接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。 4、再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。 5、最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。 ==Collection接口== ==1.List接口==List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 （1）ArrayListArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。size、isEmpty、get、set、iterator和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。ArrayList擅长于随机访问。同时ArrayList是非同步的。 （2）LinkedList同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。 与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： 1List list = Collections.synchronizedList(new LinkedList(...)); （3）Vector与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。 （4）StackStack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 ==2.Set接口==Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。需要注意的是：虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。此外需要说明一点，在set接口中的不重复是有特殊要求的。举一个例子：对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。 为了更好地理解，请看下面的例子： 12345678910public class Test&#123; public static void main(String[] args) &#123; Set&lt;String&gt; set=new HashSet&lt;String&gt;(); set.add(\"Hello\"); set.add(\"world\"); set.add(\"Hello\"); System.out.println(\"集合的尺寸为:\"+set.size()); System.out.println(\"集合中的元素为:\"+set.toString()); &#125; &#125; 运行结果： 12集合的尺寸为:2集合中的元素为:[world, Hello] 分析：由于String类中重写了hashcode和equals方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个Hello是加不进去的。 再看一个例子： 12345678910111213141516171819public class TestSet &#123; public static void main(String[] args)&#123; Set&lt;String&gt; books = new HashSet&lt;String&gt;(); //添加一个字符串对象 books.add(new String(\"Struts2权威指南\")); //再次添加一个字符串对象， //因为两个字符串对象通过equals方法比较相等，所以添加失败，返回false boolean result = books.add(new String(\"Struts2权威指南\")); System.out.println(result); //下面输出看到集合只有一个元素 System.out.println(books); &#125;&#125; 运行结果： 12false[Struts2权威指南] 123``` lasso说明：程序中，book集合两次添加的字符串对象明显不是一个对象（程序通过new关键字来创建字符串对象），当使用==运算符判断返回false，使用equals方法比较返回true，所以不能添加到Set集合中，最后只能输出一个元素。 （1）HashSetHashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致)，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。 12345HashSet使用和理解中容易出现的误区: - a.HashSet中存放null值。HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。 - b.HashSet中存储元素的位置是固定的。HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。 - c.必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。 （2）LinkedHashSetLinkedHashSet继承自HashSet，其底层是基于LinkedHashMap来实现的，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 （3）TreeSetTreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。 1注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。 ==Map接口== Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。 ==1.HashMap==以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 ==2.LinkedHashMap==LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。 1注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 ==3.TreeMap==TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。 ==Iterator 与 ListIterator详解====1.Iterator==Iterator的定义如下： public interface Iterator {}Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。 12345Iterator提供的API接口如下： - boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 - Object next()：返回集合里下一个元素。 - void remove()：删除集合里上一次next方法返回的元素。 使用示例： 1234567891011121314151617public class IteratorExample &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(\"aaa\"); a.add(\"bbb\"); a.add(\"ccc\"); System.out.println(\"Before iterate : \" + a); Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) &#123; String t = it.next(); if (\"bbb\".equals(t)) &#123; it.remove(); &#125; &#125; System.out.println(\"After iterate : \" + a); &#125;&#125; 输出结果如下： 12Before iterate : [aaa, bbb, ccc]After iterate : [aaa, ccc] 1234注意：Iterator只能单向移动。Iterator.remove()是唯一安全的方式来在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常。 ==2.ListIterator==ListIterator是一个功能更加强大的迭代器, 它继承于Iterator接口，只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。 ListIterator接口定义如下: 1234567891011121314151617181920public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void remove(); void set(E e); void add(E e);&#125; 由以上定义我们可以推出ListIterator可以: 双向移动（向前/向后遍历）. 产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引. 可以使用set()方法替换它访问过的最后一个元素. 可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素. 使用示例： 1234567891011121314151617181920212223242526272829public class ListIteratorExample &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(\"aaa\"); a.add(\"bbb\"); a.add(\"ccc\"); System.out.println(\"Before iterate : \" + a); ListIterator&lt;String&gt; it = a.listIterator(); while (it.hasNext()) &#123; System.out.println(it.next() + \", \" + it.previousIndex() + \", \" + it.nextIndex()); &#125; while (it.hasPrevious()) &#123; System.out.print(it.previous() + \" \"); &#125; System.out.println(); it = a.listIterator(1); while (it.hasNext()) &#123; String t = it.next(); System.out.println(t); if (\"ccc\".equals(t)) &#123; it.set(\"nnn\"); &#125; else &#123; it.add(\"kkk\"); &#125; &#125; System.out.println(\"After iterate : \" + a); &#125;&#125; 输出结果如下： 12345678Before iterate : [aaa, bbb, ccc]aaa, 0, 1bbb, 1, 2ccc, 2, 3ccc bbb aaa bbbcccAfter iterate : [aaa, bbb, kkk, nnn] ==异同点====1.ArrayList和LinkedList==ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 ==2.HashTable与HashMap==相同点：都实现了Map、Cloneable、java.io.Serializable接口。都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。 不同点：（1）历史原因：HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。（2）同步性：HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。（3）对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。（4）基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代M器)去遍历。然而由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。（5）支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 ==3.HashMap、Hashtable、LinkedHashMap和TreeMap比较==Hashmap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null；允许多条记录的值为Null；HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。Hashtable 与 HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.HashMap;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.TreeMap;public class MapTest &#123; public static void main(String[] args) &#123; //HashMap HashMap&lt;String,String&gt; hashMap = new HashMap(); hashMap.put(\"4\", \"d\"); hashMap.put(\"3\", \"c\"); hashMap.put(\"2\", \"b\"); hashMap.put(\"1\", \"a\"); Iterator&lt;String&gt; iteratorHashMap = hashMap.keySet().iterator(); System.out.println(\"HashMap--&gt;\"); while (iteratorHashMap.hasNext())&#123; Object key1 = iteratorHashMap.next(); System.out.println(key1 + \"--\" + hashMap.get(key1)); &#125; //LinkedHashMap LinkedHashMap&lt;String,String&gt; linkedHashMap = new LinkedHashMap(); linkedHashMap.put(\"4\", \"d\"); linkedHashMap.put(\"3\", \"c\"); linkedHashMap.put(\"2\", \"b\"); linkedHashMap.put(\"1\", \"a\"); Iterator&lt;String&gt; iteratorLinkedHashMap = linkedHashMap.keySet().iterator(); System.out.println(\"LinkedHashMap--&gt;\"); while (iteratorLinkedHashMap.hasNext())&#123; Object key2 = iteratorLinkedHashMap.next(); System.out.println(key2 + \"--\" + linkedHashMap.get(key2)); &#125; //TreeMap TreeMap&lt;String,String&gt; treeMap = new TreeMap(); treeMap.put(\"4\", \"d\"); treeMap.put(\"3\", \"c\"); treeMap.put(\"2\", \"b\"); treeMap.put(\"1\", \"a\"); Iterator&lt;String&gt; iteratorTreeMap = treeMap.keySet().iterator(); System.out.println(\"TreeMap--&gt;\"); while (iteratorTreeMap.hasNext())&#123; Object key3 = iteratorTreeMap.next(); System.out.println(key3 + \"--\" + treeMap.get(key3)); &#125; &#125;&#125; 输出结果： 123456789101112131415HashMap--&gt;3--c2--b1--a4--dLinkedHashMap--&gt;4--d3--c2--b1--aTreeMap--&gt;1--a2--b3--c4--d ==4.HashSet、LinkedHashSet、TreeSet比较==Set接口Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。 HashSetHashSet有以下特点：不能保证元素的排列顺序，顺序有可能发生变化。不是同步的。集合元素可以是null，但只能放入一个null。当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。 1注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。 LinkedHashSetLinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。 TreeSet类TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。 自然排序自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是负数，则表明obj1小于obj2。如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0。 定制排序自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.test; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.TreeSet; /** * @description 几个set的比较 * HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放； * LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代； * TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。 * @author Zhou-Jingxian * */ public class SetDemo &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;(); hs.add(\"B\"); hs.add(\"A\"); hs.add(\"D\"); hs.add(\"E\"); hs.add(\"C\"); hs.add(\"F\"); System.out.println(\"HashSet 顺序:\\n\"+hs); LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;String&gt;(); lhs.add(\"B\"); lhs.add(\"A\"); lhs.add(\"D\"); lhs.add(\"E\"); lhs.add(\"C\"); lhs.add(\"F\"); System.out.println(\"LinkedHashSet 顺序:\\n\"+lhs); TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(); ts.add(\"B\"); ts.add(\"A\"); ts.add(\"D\"); ts.add(\"E\"); ts.add(\"C\"); ts.add(\"F\"); System.out.println(\"TreeSet 顺序:\\n\"+ts); &#125; &#125; 输出结果： 123HashSet 顺序:[D, E, F, A, B, C]LinkedHashSet 顺序:[B, A, D, E, C, F]TreeSet 顺序:[A, B, C, D, E, F] ==5、Iterator和ListIterator区别==我们在使用List，Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，你不需要干涉其遍历的过程，只需要每次取出一个你想要的数据进行处理就可以了。但是在使用的时候也是有不同的。List和Set都有iterator()来取得其迭代器。对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面： ListIterator有add()方法，可以向List中添加对象，而Iterator不能 ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。 ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。 因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。 ==6、Collection 和 Collections区别==（1）java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。 1234567Collection ├List │├LinkedList │├ArrayList │└Vector │ └Stack └Set （2）java.util.Collections 是一个包装类（工具类/帮助类）。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。代码示例： 1234567891011121314151617181920import java.util.ArrayList; import java.util.Collections; import java.util.List; public class TestCollections &#123; public static void main(String args[]) &#123; //注意List是实现Collection接口的 List list = new ArrayList(); double array[] = &#123; 112, 111, 23, 456, 231 &#125;; for (int i = 0; i &lt; array.length; i++) &#123; list.add(new Double(array[i])); &#125; Collections.sort(list); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(list.get(i)); &#125; // 结果：23.0 111.0 112.0 231.0 456.0 &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://ai-guangnian.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ai-guangnian.github.io/tags/Java/"}]},{"title":"网络","slug":"WL","date":"2020-05-12T00:25:20.000Z","updated":"2020-05-12T10:13:11.460Z","comments":true,"path":"2020/05/12/WL/","link":"","permalink":"http://ai-guangnian.github.io/2020/05/12/WL/","excerpt":"TCP/IP 协议分层模型 物理层将二进制的0和1和电压高低，光的闪灭和电波的强弱信号进行转换 链路层代表驱动 网络层 使用 IP 协议，IP 协议基于 IP 转发分包数据 IP 协议是个不可靠协议，不会重发 IP 协议发送失败会使用ICMP 协议通知失败 ARP 解析 IP 中的 MAC 地址，MAC 地址由网卡出厂提供 IP 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信 传输层 TCP 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开连接，需要至少7次的发包收包，资源浪费 UDP 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层 通用的 TCP 和 UDP 协议 会话层以上分层 TCP/IP 分层中，会话层，表示层，应用层集中在一起 网络管理通过 SNMP 协议 三次握手： 客户端–发送带有SYN标志的数据包–一次握手–服务端 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端 客户端–发送带有带有ACK标志的数据包–三次握手–服务端 四次挥手： 客户端-发送一个FIN，用来关闭客户端到服务器的数据传送 服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号 服务器-关闭与客户端的连接，发送一个FIN给客户端 客户端-发回ACK报文确认，并将确认序号设置为收到序号加1","text":"TCP/IP 协议分层模型 物理层将二进制的0和1和电压高低，光的闪灭和电波的强弱信号进行转换 链路层代表驱动 网络层 使用 IP 协议，IP 协议基于 IP 转发分包数据 IP 协议是个不可靠协议，不会重发 IP 协议发送失败会使用ICMP 协议通知失败 ARP 解析 IP 中的 MAC 地址，MAC 地址由网卡出厂提供 IP 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信 传输层 TCP 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开连接，需要至少7次的发包收包，资源浪费 UDP 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层 通用的 TCP 和 UDP 协议 会话层以上分层 TCP/IP 分层中，会话层，表示层，应用层集中在一起 网络管理通过 SNMP 协议 三次握手： 客户端–发送带有SYN标志的数据包–一次握手–服务端 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端 客户端–发送带有带有ACK标志的数据包–三次握手–服务端 四次挥手： 客户端-发送一个FIN，用来关闭客户端到服务器的数据传送 服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号 服务器-关闭与客户端的连接，发送一个FIN给客户端 客户端-发回ACK报文确认，并将确认序号设置为收到序号加1 HTTP Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。 所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，成为无状态连接。 输入url到页面加载都发生了什么事情？ 输入地址 浏览器查找域名的 IP 地址 这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… 浏览器向 web 服务器发送一个 HTTP 请求 服务器的永久重定向响应（从 http://example.com 到 http://www.example.com） 浏览器跟踪重定向地址 服务器处理请求 服务器返回一个 HTTP 响应 浏览器显示 HTML 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等） 浏览器发送异步请求","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://ai-guangnian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://ai-guangnian.github.io/tags/HTTP/"},{"name":"网络","slug":"网络","permalink":"http://ai-guangnian.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://ai-guangnian.github.io/tags/TCP-IP/"}]},{"title":"第一篇博客","slug":"Page","date":"2020-05-11T12:05:57.000Z","updated":"2020-05-11T12:11:13.921Z","comments":true,"path":"2020/05/11/Page/","link":"","permalink":"http://ai-guangnian.github.io/2020/05/11/Page/","excerpt":"","text":"Hello，这是我的第一篇==博客==！","categories":[{"name":"杂文","slug":"hert","permalink":"http://ai-guangnian.github.io/categories/hert/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://ai-guangnian.github.io/tags/%E6%9D%82%E6%96%87/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-11T00:52:12.877Z","updated":"2020-05-11T14:45:55.802Z","comments":true,"path":"2020/05/11/hello-world/","link":"","permalink":"http://ai-guangnian.github.io/2020/05/11/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hello","slug":"Hello","permalink":"http://ai-guangnian.github.io/categories/Hello/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://ai-guangnian.github.io/tags/%E6%9D%82%E6%96%87/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"http://ai-guangnian.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java","slug":"Java","permalink":"http://ai-guangnian.github.io/categories/Java/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://ai-guangnian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"杂文","slug":"hert","permalink":"http://ai-guangnian.github.io/categories/hert/"},{"name":"Hello","slug":"Hello","permalink":"http://ai-guangnian.github.io/categories/Hello/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://ai-guangnian.github.io/tags/MYSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://ai-guangnian.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"http://ai-guangnian.github.io/tags/SQL/"},{"name":"Java","slug":"Java","permalink":"http://ai-guangnian.github.io/tags/Java/"},{"name":"HTTP","slug":"HTTP","permalink":"http://ai-guangnian.github.io/tags/HTTP/"},{"name":"网络","slug":"网络","permalink":"http://ai-guangnian.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://ai-guangnian.github.io/tags/TCP-IP/"},{"name":"杂文","slug":"杂文","permalink":"http://ai-guangnian.github.io/tags/%E6%9D%82%E6%96%87/"}]}